import re
import requests
from config import config
from prompts_manager import PromptsManager
from typing import Dict, List, Optional

class DocumentProcessor:
    def __init__(self):
        self.prompts = PromptsManager(config.prompts_dir)
        self.api_headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {config.deepseek_api_key}"
        }

    def extract_summary(self, text: str, max_words: int = 5) -> str:
        """ä½¿ç”¨DeepSeek APIæå–æ‘˜è¦"""
        if not text.strip():
            return ""
        
        try:
            prompt = self.prompts.get_template("summary_prompt").format(
                max_words=max_words,
                paragraph=text
            )
            
            response = requests.post(
                config.deepseek_api_url,
                headers=self.api_headers,
                json={
                    "model": "deepseek-chat",
                    "messages": [
                        {"role": "system", "content": self.prompts.get_template("system_prompt")},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.3
                },
                timeout=30
            )
            response.raise_for_status()
            
            summary = response.json()["choices"][0]["message"]["content"]
            return self._validate_summary(summary, max_words)
            
        except Exception as e:
            print(f"APIè°ƒç”¨å¤±è´¥: {e}")
            return self._fallback_summary(text, max_words)

    def _validate_summary(self, text: str, max_words: int) -> str:
        """éªŒè¯æ‘˜è¦æ ¼å¼"""
        text = re.sub(r'^["\']|["\']$', '', text.strip())
        words = text.split()[:max_words]
        return " ".join(words)

    def _fallback_summary(self, text: str, max_words: int) -> str:
        """å¤‡ç”¨æ‘˜è¦æå–æ–¹æ³•"""
        sentences = re.split(r'[.!?]+', text)
        first_sentence = sentences[0].strip() if sentences else ""
        return " ".join(first_sentence.split()[:max_words])

    def translate_text(self, text: str, source_lang: str = "auto", target_lang: str = "ä¸­æ–‡", 
                      preserve_formatting: bool = True) -> str:
        """
        ç¿»è¯‘æ–‡æœ¬ï¼ˆç‰¹åˆ«ä¿ç•™Markdownç»“æ„ï¼‰
        """
        if not text.strip():
            return ""
        
        try:
            # ä¸“é—¨é’ˆå¯¹Markdownæ–‡æ¡£çš„ç¿»è¯‘æç¤ºè¯
            prompt = f"""è¯·å°†ä»¥ä¸‹è‹±æ–‡Markdownæ–‡æ¡£å®Œæ•´ç¿»è¯‘æˆä¸­æ–‡ï¼Œä¸¥æ ¼ä¿æŒåŸæœ‰çš„Markdownæ ¼å¼å’Œç»“æ„ï¼š

{text}

é‡è¦è¦æ±‚ï¼š
1. ä¸¥æ ¼ä¿æŒæ‰€æœ‰Markdownæ ‡è®°ï¼ˆ#æ ‡é¢˜ã€##äºŒçº§æ ‡é¢˜ã€**ç²—ä½“**ã€*æ–œä½“*ç­‰ï¼‰
2. ä¿æŒæ–‡æ¡£çš„å®Œæ•´ç»“æ„ï¼ŒåŒ…æ‹¬å…ƒæ•°æ®éƒ¨åˆ†
3. æŠ€æœ¯æœ¯è¯­å’Œä¸“æœ‰åè¯ä¿æŒåŸæ ·æˆ–å‡†ç¡®ç¿»è¯‘
4. ä¸è¦æ·»åŠ æˆ–åˆ é™¤ä»»ä½•æ ¼å¼æ ‡è®°
5. ä¿æŒæ®µè½å’Œæ¢è¡Œç»“æ„ä¸å˜"""

            # è·å–ç³»ç»Ÿæç¤ºè¯
            system_prompt = self.prompts.get_template("translation_system_prompt")
            
            # è®¾ç½®è¯·æ±‚è¶…æ—¶
            response = requests.post(
                config.deepseek_api_url,
                headers=self.api_headers,
                json={
                    "model": "deepseek-chat",
                    "messages": [
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.1,
                    "max_tokens": 8000
                },
                timeout=60
            )
            response.raise_for_status()
            
            translated_text = response.json()["choices"][0]["message"]["content"]
            return self._clean_translation_result(translated_text, preserve_formatting)
            
        except Exception as e:
            print(f"âŒâŒ ç¿»è¯‘APIè°ƒç”¨å¤±è´¥: {e}")
            return self._fallback_translation(text, target_lang)

    def _clean_translation_result(self, text: str, preserve_formatting: bool) -> str:
        """æ¸…ç†ç¿»è¯‘ç»“æœ"""
        # ç§»é™¤å¯èƒ½çš„å¼•å¯¼æ–‡æœ¬
        patterns = [
            r'^ç¿»è¯‘[ï¼š:]?\s*',
            r'^ä»¥ä¸‹æ˜¯ç¿»è¯‘[ï¼š:]?\s*',
            r'^è¯‘æ–‡[ï¼š:]?\s*'
        ]
        
        for pattern in patterns:
            text = re.sub(pattern, '', text.strip())
        
        if not preserve_formatting:
            # ç®€åŒ–æ ¼å¼
            text = re.sub(r'\n+', ' ', text)
            text = re.sub(r'\s+', ' ', text)
        
        return text.strip()

    def _fallback_translation(self, text: str, target_lang: str) -> str:
        """å¤‡ç”¨ç¿»è¯‘æ–¹æ³•"""
        print(f"âš ï¸ ä½¿ç”¨å¤‡ç”¨ç¿»è¯‘æ–¹æ¡ˆ for {target_lang}")
        return f"[å¤‡ç”¨ç¿»è¯‘] {text}"

    def batch_translate(self, texts: List[str], source_lang: str = "auto", 
                       target_lang: str = "ä¸­æ–‡", batch_size: int = 5) -> List[str]:
        """
        æ‰¹é‡ç¿»è¯‘æ–‡æœ¬
        
        Args:
            texts: æ–‡æœ¬åˆ—è¡¨
            source_lang: æºè¯­è¨€
            target_lang: ç›®æ ‡è¯­è¨€
            batch_size: æ‰¹å¤„ç†å¤§å°
        
        Returns:
            ç¿»è¯‘åçš„æ–‡æœ¬åˆ—è¡¨
        """
        results = []
        
        for i in range(0, len(texts), batch_size):
            batch = texts[i:i + batch_size]
            print(f"ğŸ”„ğŸ”„ ç¿»è¯‘æ‰¹æ¬¡ {i//batch_size + 1}/{(len(texts)-1)//batch_size + 1}")
            
            for text in batch:
                try:
                    translated = self.translate_text(text, source_lang, target_lang)
                    results.append(translated)
                except Exception as e:
                    print(f"âŒâŒ ç¿»è¯‘å¤±è´¥: {e}")
                    results.append(f"[ç¿»è¯‘å¤±è´¥] {text}")
            
            # æ·»åŠ å»¶è¿Ÿé¿å…APIé™åˆ¶